<figure class="code pattern-matching">
  <figcaption>Pattern matching</figcaption>
  <pre><code>// Define a set of case classes for representing binary trees.
sealed abstract class Tree[+A]
case class Node[+A](elem: A, left: Tree[A], right: Tree[A]) extends Tree[A]
case object Leaf extends Tree[Nothing]

// Return the in-order traversal sequence of a given tree.
def inOrder[A](t: Tree[A]): List[A] = t match {
  case Node(e, l, r) => inOrder(l) ::: List(e) ::: inOrder(r)
  case Leaf          => List()
}</code></pre>
</figure>

<div class="snippet-explanation">
  <h3>Switch on the structure of your data</h3>
<p>In Scala, <em>case classes</em> are used to represent structural data
types. The implicitly equip the class with meaningful <code>toString</code>,
<code>equals</code> and <code>hashCode</code> methods, as well as the
ability to be deconstructed with <em>pattern matching</em>.</p>
<p>
In this example, we define a small set of case classes that represent binary
trees of a generic type <code>A</code>.
In <code>inOrder</code>, the <code>match</code> construct chooses the right
branch, depending on the type of <code>t</code>, and at the same time
deconstructs the arguments of a <code>Node</code>.
</p></div>
