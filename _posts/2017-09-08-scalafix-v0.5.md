---
category: blog
by: Ólafur Páll Geirsson
title: "Catch bugs with Scalafix v0.5"
date: 9-9-2017
---

I am excited to announce the release of [Scalafix v0.5.0][].
This release introduces new features in addition to several bug fixes and
integration improvements.

If you are not familiar with Scalafix, Scalafix is a rewrite and linting tool
for Scala.
The project is developed at the [Scala Center][sc] with the mission to help
automate migration between different Scala compiler and library versions.

> This is the third post on Scalafix and scalameta.
> You might be interested in reading the previous post
> [here](http://www.scala-lang.org/blog/2017/02/27/Scalafix-v0.3.html).


## Linting

Scalafix v0.5 supports linters.
Linters are programs that analyze source code for potential bugs.
Before v0.5, Scalafix rules could only "fix" code by providing rewrite instructions.
Now, it's possible to implement Scalafix rules that only report messages instead
of rewrite instructions.
Each category of lint messages is attached to a default severity level
(info/warn/error), which users can override via configuration.

The first Scalafix linter is [`NoInfer`][].
`NoInfer` reports errors when the Scala compiler infers one of the following types:
`Any`, `AnyVal`, `Product` or `Serializable`.
It's usually a bad sign when the compiler infers such a generic type.
In those cases, it's better to explicitly type annotate the expected type.


### Building a custom linter
It's simple to implement custom Scalafix linters.
To demonstrate this, let's implement a `NoDefaultParams` linter that reports an error if
default parameter values are used.
To begin with, we motivate this linter rule with a bit of documentation.

<script src="https://gist.github.com/olafurpg/38699f591329c3bcff52b7412dcb696b.js"></script>

Looks good, now we can implement the Scalafix rule.
Rules are implemented with Scalafix and Scalameta.
The `param"..."` part is a [quasiquote][], which is a simple way to construct
or pattern-match a Scalameta tree from syntax.

```scala
import scalafix._
import scala.meta._
case object NoDefaultParams extends Rule("NoDefaultParams") {
  val error = LintCategory.error(
    "Default parameter values should be avoided, use method overloading instead. " +
      "Details: https://gist.github.com/olafurpg/38699f591329c3bcff52b7412dcb696b"
  )
  override def check(ctx: RuleCtx): List[LintMessage] = ctx.tree.collect {
    case param"..$_ $_: $_ = ${Some(default)}" =>
      error.at(s"default parameter values are not allowed.", default.pos)
  }
}
```

When `NoDefaultParams` encounters a parameter with a default parameter value,
it will report a message like this

```scala
scala/test/NoDefaultParams.scala:8: error: [NoDefaultParams] default parameter values are not allowed.
  def foo(e: Int = 2) = e
                   ^
```
The reported message looks great, let's share the `NoDefaultParams`
implementation as a gist:
<https://gist.github.com/olafurpg/7b022c7120156716def282028b091e8b>.

We can use scalafix-testkit to test that our rewrite works as expected.
Tests are written in plain .scala files.
The top of the file contains a comment including configuration to tell Scalafix
which rule to run.
Rules can also have their own configuration section, but that's out of scope
for this blog post.

```scala
/*
rule = "https://gist.githubusercontent.com/olafurpg/7b022c7120156716def282028b091e8b/raw/2a83cfc22462804c53a9fb67d0c0220b8b82f124/NoDefaultParameters.scala"
*/
class NoDefaultParamsTest {
  def foo(e: Int = 2) = e // assert: NoDefaultParams
  def bar(e: Int) = e
}
```

The `// assert: NoDefaultParams` comment asserts that a linter message with id "NoDefaultParams" is reported
on line 7.
The test fails if

- a message is not reported on that line
- a message is reported on that line but the category id doesn't match,
- a message is reported at a line without an assert

`NoDefaultParams` has docs✅ now, an implementation ✅ and tests ✅, our linting rule is
ready for a release!
There is no need to setup a complicated publish step to Maven Central.
Scalafix is able to run custom rules from source.
Our friends can try out `NoDefaultParams` by installing [sbt-scalafix][]
and execute from the sbt shell

```
sbt> scalafix https://gist.githubusercontent.com/olafurpg/7b022c7120156716def282028b091e8b/raw/2a83cfc22462804c53a9fb67d0c0220b8b82f124/NoDefaultParameters.scala
```

To implement your own custom rewrites, jumpstart with our
[scalacenter/scalafix.g8](https://github.com/scalacenter/scalafix.g8)
template, which sets up a minimal sbt project with testing scaffolding.
To learn more about implementing custom rules, refer to our
[documentation](https://scalacenter.github.io/scalafix/#Creatingyourownrule).

> Note. Scalafix has not at all shifted away its focus from rewriting.
> The idea to use Scalafix for linting initially started as a discussion in
> [Scala Contributors][].
> It turned out to be simple to add basic linting capabilities with the
> existing Scalafix infrastructure.

## sbtfix

Another notable new feature in Scalafix v0.5 is the ability to rewrite sbt build
sources with access to the semantic API.
The first available sbt rewrite is [`Sbt1`][], which migrates several deprecated 
sbt "fishy operators" such as `<++=` to the recommended `.value` DSL.
To run `Sbt1` on your 0.13 build, follow the installation instructions for
the [sbt-scalafix][] plugin and execute `> sbtfix Sbt1`.

It's possible to implement custom sbtfix rules just like regular Scalafix rules.
No custom setup is required from rule authors to fix sbt source files.
The semantic API to resolve names and symbols signatures is supported, but
advanced sections such as `Synthetics` (which `NoInfer` use) are not.
I am excited to see what the community can build with this new functionality.
Some ideas that come to my mind include

- update library dependency versions
- install new library dependencies
- automatically enforce sbt best-practices

To learn more about how Scalafix supports semantic analysis of sbt 0.13 and
Scala 2.10 sources, see [semanticdb-sbt][].

> Note.
> Semantic API support for *.sbt files is still only at a "proof-of-concept"
> stage. The current implementation requires more engineering work to reach
> the same level of coverage as the semantic API for 2.11/2.12 *.scala source 
> files.

## Tab completion

Scalafix v0.5 improves the sbt-scalafix plugin and scalafix-cli in many ways.
Most of these bug fixes and improvements involve fairly boring
behind-the-scenes mechanics.
However, I believe one small quality-of-life improvement is worth highlighting:
*tab completion of Scalafix rules*.

![Scalafix tab completion]({{ site.baseurl }}/resources/img/Scalafix-tab-completion.gif)

Tab completion is supported in sbt-scalafix as well as for scalafix-cli in
bash and zsh.
Tab completion makes it easier to discover which rewrites are available and
help prevents typos when spelling out rewrite names.
To install completions for scalafix-cli, follow the instructions in `--help`.

## What's next

I believe we will soon reach a tipping point for Scala tooling.
Semantic analysis of Scala programs has traditionally been tricky business,
requiring intimate familiarity with compiler internals.
Scalameta and Scalafix involve none of that.
For example, the core logic of the `NoInfer` rule is implemented in
[10 lines][NoInfer] of fairly straightforward, immutable and functional code.

Next steps for Scalafix include:

* more comprehensive understanding of "synthetics" such as inferred implicit
  arguments, [#266][]. This is important for Dotty migration rewrites.
* more linting rules. I would love to unite efforts with Scalastyle and
  Wartremover to offer an extensive set of linting rules in a single tool.
  Scalafix can definitely benefit from their experience in this space.
* more complete `Sbt1` rewrite to accellerate sbt 1.0 migration, see
  [sbtfix issues][].
* more polished integrations. Currently, running Scalafix in a large project
  typically results in many spurious errors and warnings.

I encourage everyone to get involved if they want to improve the state of Scala tooling.
If you are interested in contributing, don't hesitate to stop by the
[Scalafix Gitter channel][Gitter].

PS. I want to shout out to [Gabriele Petronella][gabro], who made major
contributions to Scalafix v0.4 and v0.5 via PRs and discussions.
If you use cats, then you might be interested in his
[cats v1.0 migration rewrites][cats].

[cats]: https://github.com/typelevel/cats/blob/master/scalafix/README.md
[scalameta/semanticdb-sbt]:https://github.com/scalameta/sbthost 
[sbt-scalafix]: https://scalacenter.github.io/Scalafix/#sbt-scalafix
[scala210]: https://contributors.scala-lang.org/t/continuing-or-dropping-scala-2-10-maintenance-in-the-ecosystem/1013
[sc]: http://scala.epfl.ch/
[quasiquote]: https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md
[Scalafix v0.5.0]: https://scalacenter.github.io/scalafix/#0.5.0
[Scalameta]: http://scalameta.org/
[NoInfer]: https://github.com/scalacenter/scalafix/blob/1cfbfe02bda4946488be4d95ce2507cc362624b1/scalafix-core/shared/src/main/scala/scalafix/internal/rule/NoInfer.scala#L21-L31
[gabro]: https://twitter.com/gabro27
[#266]: https://github.com/scalacenter/scalafix/issues/266
[sbtfix issues]: https://github.com/scalacenter/scalafix/labels/sbtfix
[semanticdb-sbt]: https://github.com/scalameta/semanticdb-sbt
[Gitter]: https://gitter.im/scalacenter/scalafix
[Scala Contributors]: https://contributors.scala-lang.org/t/whats-the-status-of-abide/609
[`Sbt1`]: https://scalacenter.github.io/scalafix/#Sbt1
[`NoInfer`]: https://scalacenter.github.io/scalafix/#NoInfer
